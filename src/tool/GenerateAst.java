package tool;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class GenerateAst {
    private static final List<String> javaKeyword = List.of(
            "abstract",
            "assert",
            "boolean",
            "break",
            "byte",
            "case",
            "catch",
            "char",
            "class",
            "const",
            "continue",
            "default",
            "do",
            "double",
            "else",
            "enum",
            "extends",
            "false",
            "final",
            "finally",
            "float",
            "for",
            "goto",
            "if",
            "implements",
            "import",
            "instanceof",
            "int",
            "interface",
            "long",
            "native",
            "new",
            "null",
            "package",
            "private",
            "protected",
            "public",
            "return",
            "short",
            "static",
            "super",
            "switch",
            "synchronized",
            "this",
            "throw",
            "throws",
            "transient",
            "true",
            "try",
            "void",
            "volatile",
            "while",
            "");

    public static void main(String[] args) throws IOException {
        if (args.length > 1) {
            System.err.println("Usage: generate_ast [output directory]");
            System.exit(64);
        }
        String outputDir = args.length == 1 ? args[0] : "src/jlox";
        // printPWD();

        // Generate expressions
        Path exprPath = Path.of("src/tool/expressions.txt");
        var expressions = Files.readString(exprPath).split("\n");
        defineAst(outputDir, "Expr", List.of(expressions), true);

        // generate statements
        Path stmtPath = Path.of("src/tool/statements.txt");
        var statements = Files.readString(stmtPath).split("\n");
        defineAst(outputDir, "Stmt", List.of(statements), false);
    }

    @SuppressWarnings("unused")
    private static void printPWD() {
        var currentRelativePath = Paths.get("");
        String s = currentRelativePath.toAbsolutePath().toString();
        System.out.println("Current absolute path is: " + s);
    }

    private static String uncapitalize(boolean preferClassName, String className, String baseName) {
        preferClassName = preferClassName &&  !javaKeyword.contains(className.toLowerCase());
        String string = preferClassName ? className : baseName;
        return Character.toLowerCase(string.charAt(0)) + string.substring(1);
    }

    @SuppressWarnings("SameParameterValue") // baseName
    private static void defineAst(String outputDir, String baseName, List<String> types, boolean nameFromClassName)
            throws IOException {
        String path = outputDir + '/' + baseName + ".java";
        try (var writer = new PrintWriter(path, StandardCharsets.UTF_8)) {
            writer.print(
                    """
                    // Automatically generated by jlox.tool.GenerateAst
                                    
                    package jlox;
                    import java.util.List;
                                        
                    @SuppressWarnings("unused")
                    abstract class %s {
                    """.formatted(baseName)
            );

            defineVisitor(writer, baseName, types, VisitorType.Return, nameFromClassName);
            defineVisitor(writer, baseName, types, VisitorType.Void, nameFromClassName);
            defineVisitor(writer, baseName, types, VisitorType.Walk, nameFromClassName);

            for (String type : types) {
                if (type == null || type.equals("") || type.startsWith("//")) continue;
                String className = type.split(":")[0].trim();
                String fields = type.split(":")[1].trim();
                defineType(writer, baseName, className, fields);
            }

            // Class end
            writer.print(
                    """
                              
                        abstract void voidVisit(VoidVisitor visitor);

                        @SuppressWarnings("UnusedReturnValue")
                        abstract <R> R visit(Visitor<R> visitor);
                        
                        abstract void enter(WalkVisitor visitor);
                        abstract void leave(WalkVisitor visitor);
                    }
                    """
            );
        }
    }

    private static void defineType(PrintWriter writer, String baseName, String className, String fields) {
        // Class start
        writer.println(
                """
                  static class %s extends %s {
                """.formatted(className, baseName));

        // Fields
        for (String field : fields.split(", ")) {
            if (field.contains("=")) {
                writer.println("    %s;".formatted(field));
            } else {
                writer.println("    final %s;".formatted(field));
            }
        }

        // Constructor start
        writer.println(
                "\n    %s ( %s ) {".formatted(
                        className,
                        Arrays.stream(fields.split(", "))
                                .filter(field -> !field.contains("="))
                                .collect(Collectors.joining(", "))));
        // > Initialise field
        for (String field : fields.split(", ")) {
            if (field.contains("=")) continue;
            String name = field.split(" ")[1];
            writer.println(
                    "      this.%s = %s;".formatted(name, name));
        }
        // > Constructor end
        writer.println("    }");

        writer.print(
                """
                    
                    @Override
                    void voidVisit(VoidVisitor visitor) {
                        visitor.visit%1$s%2$s(this);
                    }

                    @Override
                    void enter(WalkVisitor visitor) {
                        visitor.enter%1$s%2$s(this);
                    }

                    @Override
                    void leave(WalkVisitor visitor) {
                        visitor.leave%1$s%2$s(this);
                    }

                    @Override
                    <R> R visit(Visitor<R> visitor) {
                        return visitor.visit%1$s%2$s(this);
                    }
                """.formatted(className, baseName)
        );

        // Class end
        writer.println("  }");
    }

    private enum VisitorType { Return, Void, Walk }

    private static void defineVisitor(PrintWriter writer,
                                      String baseName,
                                      List<String> types,
                                      VisitorType visitorType,
                                      boolean nameFromClassName) {
        // Interface start
        writer.println( "  interface " + switch (visitorType) {
            case Return -> "Visitor<R>";
            case Void -> "VoidVisitor";
            case Walk -> "WalkVisitor";
        } + " {");

        // Methods
        for (String type : types) {
            if (type == null || type.equals("") || type.startsWith("//")) continue;
            String className = type.split(":")[0].trim();
            String methods = switch (visitorType) {
                case Return -> "    R visit%s%s(%s %s);";
                case Void -> "    void visit%s%s(%s %s);";
                case Walk -> "    void enter%1$s%2$s(%3$s %4$s);\n    void leave%1$s%2$s(%3$s %4$s);";
            };
            writer.println(methods.formatted(className, baseName, className,
                        uncapitalize(nameFromClassName, className, baseName)));
        }

        // Interface end
        writer.println("  }");
    }
}
