description ¤ input ¤ expectedErrors

# Binary operator
Operator > ¤ true > 5 ¤ at '>', left operand, number expected
Operator > ¤ 5 > true ¤ at '>', right operand, number expected
Operator > ¤ true > true ¤ at '>', left operand, number expected
Operator >= ¤ true >= 5 ¤ at '>=', left operand, number expected
Operator < ¤ true < 5 ¤ at '<', left operand, number expected
Operator <= ¤ true <= 5 ¤ at '<=', left operand, number expected
Operator - ¤ true - 5 ¤ at '-', left operand, number expected
Operator * ¤ true * 5 ¤ at '[*]', left operand, number expected
Operator / ¤ true / 5 ¤ at '/', left operand, number expected

# Operator +
Operator + incompatible operands ¤ true + false ¤ at '[+]', operands cannot be added
Operator + incompatible operands ¤ 1 + false ¤ at '[+]', operands cannot be added
Operator + incompatible operands ¤ false + 1 ¤ at '[+]', operands cannot be added

# Division by zero
Division by zero ¤ 3 / 0 ¤ at '/', division by zero
Division by zero ¤ 0 / 0 ¤ at '/', division by zero
Division by zero ¤ 1.5 / 0 ¤ at '/', division by zero
Division by zero ¤ 1.5 % 0 ¤ at '%', division by zero

# Unary operator
Unary - ¤ - true ¤ at '-', right operand, number expected

# Undefined variables (symbols)
Undefined symbol in expression ¤ a ¤ at 'a', undefined identifier 'a'
Undefined symbol in multiple expression ¤ b + a ¤ at 'b', undefined identifier 'b'
Undefined symbol in assignment ¤ a = 10 ¤ at 'a', undefined identifier 'a'
Undefined symbol in chained assignment ¤ var a; c = b = a = 10 ¤ at 'b', undefined identifier 'b'
Uninitialized variable ¤ var a; 10 + a + 5 ¤ at 'a', variable 'a' is uninitialized

# Block scope
Undefined variable out of scope ¤ var b = 20; { var a = 10; print a; } b + a ¤ undefined identifier 'a', /P0

# For loop
For loop local variable out of scope ¤ for (var a = 0; a < 5; a = a + 1); a ¤ undefined identifier 'a'

# Increment & Decrement
Increment boolean ¤ var i = true; ++i ¤ at 'i', expected 'Double' but got 'Boolean'
Decrement string ¤ var str = "a"; --str ¤ at 'str', expected 'Double' but got 'String'
Decrement nil ¤ var str = nil; --str ¤ at 'str', expected 'Double' but got 'Void'

# Native functions
Native clock takes 0 arg, not 1 ¤ clock(1) ¤ at '[(]', call expect 0 arguments, but got 1
Native clock takes 0 arg, not 3 ¤ clock(1, 2, 3) ¤ at '[(]', call expect 0 arguments, but got 3
Native lineSeparator takes 0 arg, not 2 ¤ lineSeparator(1, 2) ¤ at '[(]', call expect 0 arguments, but got 2
Native exit takes 1 arg, not 0 ¤ exit() ¤ at '[(]', call expect 1 arguments, but got 0
Native exit takes 1 arg, not 2 ¤ exit(1, 2) ¤ at '[(]', call expect 1 arguments, but got 2
Native exit expect number arg ¤ exit(false) ¤ at '[(]', type mismatch, expected 'double', got 'boolean'
Native exit expect number arg ¤ exit(""string"") ¤ at '[(]', type mismatch, expected 'double', got 'string'
Native exit expect number arg ¤ exit(nil) ¤ at '[(]', type mismatch, expected 'double', got 'void'

# Return
# TODO move to Static Analysis, because not really  runtime checks
Return outside any function 1 ¤ return; ¤ return outside function
Return outside any function 2 ¤ { return; } ¤ return outside function
Dead code 1 ¤ fun f() { print 30; return; 10; 20; } f(); ¤ /120, dead code, 10, 20, *30
Dead code 2 ¤ fun f() { print 30; { return; print 10; } print 20; } f(); ¤ /120, dead code, print 10, print 20, *30

# Lexical scope
Lexical scope 1 (var after fun)  ¤ fun plus(a) { print a + b; }; var b = 10; plus(5); ¤ /001, at 'b', undefined identifier

# Redefinition
Redefinition global ok ¤ var a = 10; var a = 20; print a; ¤ /100, *20
Redefinition local bad ¤ { var a = 10; var a = 20; fun a() {}; print a; } ¤ /002, variable 'a', cannot be redeclared
Redefinition parameters bad ¤ fun plus(b, b, b) {b;} ¤ /002, parameter 'b', cannot be redeclared
Redefinition sub block ok ¤ { var a = 10; { var a = 20; print a; } print a; } ¤ /200, *10, *20
Redefinition parameter in body bad ¤ fun f(a) { var a = 10; print a; } f(5); ¤ /001, parameter 'a', cannot be redeclared
Redefinition parameter in body bad ¤ var f = fun (a) { var a = 10; print a; }; f(5); ¤ /001, parameter 'a', cannot be redeclared

# Unused symbol: variable, parameter, function
Unused global ok ¤ var a = 10; ¤ /000
Unused local variable bad ¤ { var b = 10; } ¤ /010, variable 'b' is unused
Unused local function bad ¤ { fun f() 10; } ¤ /010, function 'f' is unused
Unused local parameter bad ¤ { fun f(p) 10; } ¤ /020, function 'f' is unused, parameter 'p' is unused
Used in sub-block ok ¤ { var b = 10; { print b; } } ¤ /100, *10
Used in sub-function ok ¤ { var b = 10; fun f(){ print b; }; f(); } ¤ /100, *10
Unused reflexive function 1 ¤ { fun f() f(); } ¤ /010, function 'f' is unused
Unused reflexive function 2 ¤ { fun facto(n) n <= 2 ? n : n * facto (n - 1); } ¤ /010, function 'facto' is unused
Unused sub reflexive ¤ { fun f() { fun g() { f(); } return g; }} ¤  /010, function 'f' is unused

# Class
Class declaration ¤ class C { } print C; ¤ *class C
Class declaration unused ¤ { class C { } } ¤ /010, class 'C' is unused
Class declaration with methods 1 ¤ class CC { write () { \n } \n } print CC; ¤ *class CC
Class declaration with methods 2 ¤ class CC { write (a) { print a; } } print CC; ¤ *class CC
# TODO function 'write' is unused in the following (was fine before introducing a new scope for self)
Class declaration with methods (local) ¤ { class CC { write () { \n } \n } print CC; } ¤ /100, *class CC
Class instantiation ¤ class D { } D() ¤ /100, *D instance
Class field ¤ class C{} var c = C(); c.field = 10; c.field ¤ /100, *10
Class field undefined ¤ class C{} var c = C(); c.field ¤ /001, undefined property 'field'
Class not valid instance ¤ 10.size ¤ /001, left side of '.size' is not an instance
Class not valid instance ¤ 10.max = 30 ¤ /001, left side of '.max' is not an instance
Class field chained ¤ class C{} var c = C(); c.alpha = C(); c.alpha.beta = 12; c.alpha.beta ¤ /100, *12
Class field indirect ¤ class C{} var c = C(); fun f() c; f().gamma = 32; f().gamma ¤ /100, *32
Class method get ¤ class C { hello(name) { print ""hello "" + name; } } var c = C(); c.hello ¤ /100, *<method: hello>
Class method call ¤ class C { hello(name) { print ""hello "" + name; } } var c = C(); c.hello(33); ¤ /100, *hello 33

# Self
Self is not usable as a variable ¤ var self = 0; ¤ /001, at 'self', Expect variable name
Self is not usable as a function name ¤ fun self(){} ¤ /001, at 'self', Expect function name
Self is not usable as a parameter name ¤ fun f(self){} ¤ /001, at 'self', Expect parameter name
Self is not usable as a class name ¤ class self{} ¤ /001, at 'self', Expect class name
# TODO report only one error for the following error (synchronization problem)
Self is not usable as a method name ¤ class C { self(){} \n} ¤ /002, at 'self', Expect method name
Self cannot be redefined ¤ class C { f(){ self = 4; } } ¤ /001, at 'self', 'self' cannot be modified
Self is not defined outside a class 1 ¤ print self; ¤ /001, undefined identifier 'self'
Self is not defined outside a class 2 ¤ fun f() { print self; } ¤ /001, undefined identifier 'self'
Self inside class ¤ class C { info() { print self; }} C().info(); ¤ /100, *C instance

# Constructor (init)
Init simple ¤ class C { init() { print 10; } } C(); C(); ¤ /200, *10.*10
Init with params ¤ class Bed { init(size) { self.size = size; } } var bed = Bed(20); bed.size ¤ /100, *20
Init with bad arity ¤ class Bed { init(size) { self.size = size; } } var bed = Bed(20, 30); bed.size ¤ /001, expect 1
Init with bad arity ¤ class Bed { init(size) { self.size = size; } } var bed = Bed(); bed.size ¤ /001, expect 1
Init direct invocation ¤ class Bed { init(size) { self.size = size; } } var bed = Bed(10); bed.init(20); bed.size ¤ /100, *20
Init return self ¤ class Bed { init(size) { self.size = size; } } var bed = Bed(10); bed.init(20).init(30); bed.size ¤ /100, *30
Init return self upon return ¤ class Bed { init(size) { self.size = size; return; } } var bed = Bed(10); bed.init(20).init(30); bed.size ¤ /100, *30
Init cannot return a value ¤ class C { init() { return 10; } } ¤ /001, at 'return', initializers cannot return something